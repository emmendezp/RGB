<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Taller 2 : Visual Masking # Planteamiento del problema # Identificar, implementar y discutir posibles aplicaciones de algunas ilusiones ópticas conocidas en el diseño y desarrollo de gráficos por computadora.
Máscaras de convolución # Explicación visual : # En matemáticas (en particular, análisis funcional), la convolución es una operación matemática sobre dos funciones (f y g) que produce una tercera función (f * g) que expresa cómo la forma de una es modificada por la otra."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Taller 2 : Visual Masking # Planteamiento del problema # Identificar, implementar y discutir posibles aplicaciones de algunas ilusiones ópticas conocidas en el diseño y desarrollo de gráficos por computadora.
Máscaras de convolución # Explicación visual : # En matemáticas (en particular, análisis funcional), la convolución es una operación matemática sobre dos funciones (f y g) que produce una tercera función (f * g) que expresa cómo la forma de una es modificada por la otra."><meta property="og:type" content="article"><meta property="og:url" content="https://emmendezp.github.io/RGB/docs/Talleres/visual_Masking/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-09-06T09:57:55-05:00"><title>Visual Masking | Computacion Visual 2022-2 RGB</title><link rel=manifest href=/RGB/manifest.json><link rel=icon href=/RGB/favicon.png type=image/x-icon><link rel=stylesheet href=/RGB/book.min.ab46de3e725a6415339a37bba23a0067534a37289b063c9f8d011515a63097a8.css integrity="sha256-q0bePnJaZBUzmje7ojoAZ1NKNyibBjyfjQEVFaYwl6g=" crossorigin=anonymous><script defer src=/RGB/flexsearch.min.js></script>
<script defer src=/RGB/en.search.min.40c79df5316a81ce33442a329ac84a3e97685851d7968f8487f6a9c966c1b799.js integrity="sha256-QMed9TFqgc4zRCoymshKPpdoWFHXlo+Eh/apyWbBt5k=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/RGB/><span>Computacion Visual 2022-2 RGB</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-bab8b9365022340ebec5653746d3d735 class=toggle>
<label for=section-bab8b9365022340ebec5653746d3d735 class="flex justify-between"><a href=/RGB/docs/Ejercicios/>Ejercicios</a></label><ul><li><a href=/RGB/docs/Ejercicios/Ejercicio1/>Ejercicio1</a></li><li><a href=/RGB/docs/Ejercicios/Ejercicio2/>Ejercicio2</a></li></ul></li><li><input type=checkbox id=section-9370f1a5d0248572ac505e0c6d4ad190 class=toggle>
<label for=section-9370f1a5d0248572ac505e0c6d4ad190 class="flex justify-between"><a href=/RGB/docs/shortcodes/>Shortcodes</a></label><ul><li><a href=/RGB/docs/shortcodes/buttons/>Buttons</a></li><li><a href=/RGB/docs/shortcodes/columns/>Columns</a></li><li><a href=/RGB/docs/shortcodes/details/>Details</a></li><li><a href=/RGB/docs/shortcodes/hints/>Hints</a></li><li><a href=/RGB/docs/shortcodes/katex/>Katex</a></li><li><a href=/RGB/docs/shortcodes/mermaid/>Mermaid</a></li><li><input type=checkbox id=section-ec67a64aba70b9df3d2a9acd6c92e3bc class=toggle>
<label for=section-ec67a64aba70b9df3d2a9acd6c92e3bc class="flex justify-between"><a href=/RGB/docs/shortcodes/p5/>P5</a></label><ul><li><a href=/RGB/docs/shortcodes/p5/div/>Div</a></li><li><a href=/RGB/docs/shortcodes/p5/iframe/>Iframe</a></li></ul></li><li><a href=/RGB/docs/shortcodes/tabs/>Tabs</a></li></ul></li><li><input type=checkbox id=section-042d3f228c0d48b7873225f7fc71e929 class=toggle checked>
<label for=section-042d3f228c0d48b7873225f7fc71e929 class="flex justify-between"><a href=/RGB/docs/Talleres/>Talleres</a></label><ul><li><a href=/RGB/docs/Talleres/visual_ilusions/>Visual Ilusions</a></li><li><a href=/RGB/docs/Talleres/visual_Masking/ class=active>Visual Masking</a></li></ul></li></ul><ul><li><a href=/RGB/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/RGB/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Visual Masking</strong>
<label for=toc-control><img src=/RGB/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#taller-2--visual-masking>Taller 2 : Visual Masking</a><ul><li><a href=#planteamiento-del-problema>Planteamiento del problema</a></li><li><a href=#máscaras-de-convolución>Máscaras de convolución</a><ul><li><a href=#explicación-visual->Explicación visual :</a></li><li><a href=#ejemplo>Ejemplo</a></li></ul></li><li><a href=#image-kernel>Image Kernel</a><ul><li><a href=#convolution->Convolution :</a></li><li><a href=#example>Example</a></li></ul></li></ul></li><li><a href=#the-coffee-shop-wall-illusion>The coffee shop wall illusion</a></li><li><a href=#image-histragram>Image Histragram</a></li></ul></nav></aside></header><article class=markdown><h1 id=taller-2--visual-masking>Taller 2 : Visual Masking
<a class=anchor href=#taller-2--visual-masking>#</a></h1><h2 id=planteamiento-del-problema>Planteamiento del problema
<a class=anchor href=#planteamiento-del-problema>#</a></h2><p>Identificar, implementar y discutir posibles aplicaciones de algunas ilusiones ópticas conocidas en el diseño y desarrollo de gráficos por computadora.</p><h2 id=máscaras-de-convolución>Máscaras de convolución
<a class=anchor href=#m%c3%a1scaras-de-convoluci%c3%b3n>#</a></h2><h3 id=explicación-visual->Explicación visual :
<a class=anchor href=#explicaci%c3%b3n-visual->#</a></h3><p><a href=https://imgur.com/cH0Iyea><img src=https://i.imgur.com/cH0Iyea.gif title="source: imgur.com"></a></p><p>En matemáticas (en particular, análisis funcional), la convolución es una operación matemática sobre dos funciones (f y g) que produce una tercera función (f * g) que expresa cómo la forma de una es modificada por la otra. El término conv olución se refiere tanto a la función de resultado como al proceso de calcularla. Se define como la integral del producto de las dos funciones después de que una se refleja sobre el eje y y se desplaza. La elección de qué función se refleja y desplaza antes de la integral no cambia el resultado de la integral (ver conmutatividad). La integral se evalúa para todos los valores de desplazamiento, produciendo la función de convolución.</p><h3 id=ejemplo>Ejemplo
<a class=anchor href=#ejemplo>#</a></h3><iframe id=breath style=width:700px;height:450px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              

// this class describes the structure
// and movents of the brick
class Brick{
  constructor(bc, y){
    this.brickColor = bc;
    this.yPos = y;
    this.xPos = 0;
  }

  // this function creates the brick
  createBrick(){
    fill(this.brickColor);
    rect(this.xPos, this.yPos, 100, 50);
  }

  // this function sets the speed
  // of movement of the brick to 1
  setSpeed(){
    this.xSpeed = 1;
  }

  // this function set the bricks in motion
  moveBrick(){
    this.xPos+=this.xSpeed;
    if(this.xPos+100 >= width || this.xPos <= 0){
      this.xSpeed*=-1;
    }
  }
}

function setup() {
  createCanvas(720, 400);
  createP(&#34;Keep the mouse clicked&#34;).style('color','#ffffff');
  createP(&#34;to check whether the bricks&#34;).style('color','#ffffff');
  createP(&#34;are moving at same speed or not&#34;).style('color','#ffffff');
}

// creating two bricks of
// colors white and black
let brick1 = new Brick(&#34;white&#34;,100);
let brick2 = new Brick(&#34;black&#34;,250);

//
brick1.setSpeed();
brick2.setSpeed();

function draw () {
  background(0);
  if(mouseIsPressed){
    background(50);
  }
  brick1.createBrick();
  brick1.moveBrick();
  if(!mouseIsPressed){
    createBars();
  }
  brick2.createBrick();
  brick2.moveBrick();
}

// this function creates the black and
// white bars across the screen
function createBars() {
  let len = 12;
  for(let i = 0;i< width/len;i++){
    fill(&#34;white&#34;);
    if(i%2 == 0)
    rect(i*len,height,len,-height);
  }
}


            </script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h2 id=image-kernel>Image Kernel
<a class=anchor href=#image-kernel>#</a></h2><p>En el procesamiento de imágenes, un núcleo, una matriz de convolución o una máscara es una matriz pequeña que se utiliza para desenfocar, agudizar, grabar, detectar bordes y más. Esto se logra haciendo una convolución entre el kernel y una imagen.</p><h3 id=convolution->Convolution :
<a class=anchor href=#convolution->#</a></h3><p>La convolución es el proceso de agregar cada elemento de la imagen a sus vecinos locales, ponderados por el kernel. Esto está relacionado con una forma de convolución matemática. La operación de matriz que se está realizando, la convolución, no es una multiplicación de matriz tradicional, a pesar de que se indica de manera similar con *.</p><p>Por ejemplo, si tenemos dos matrices de tres por tres, la primera es un kernel y la segunda una pieza de imagen, la convolución es el proceso de invertir tanto las filas como las columnas del kernel y multiplicar localmente entradas y sumas similares. El elemento en las coordenadas [2, 2] (es decir, el elemento central) de la imagen resultante sería una combinación ponderada de todas las entradas de la matriz de la imagen, con pesos dados por el kernel:</p><p><a href=https://imgur.com/WKClpxS><img src=https://i.imgur.com/WKClpxS.gif title="source: imgur.com"></a></p><h3 id=example>Example
<a class=anchor href=#example>#</a></h3><iframe id=breath style=width:700px;height:450px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              

 
let img;
let w = 80;

// It's possible to convolve the image with many different 
// matrices to produce different effects. This is a high-pass 
// filter; it accentuates the edges. 
const matrix = [ [ -1, -1, -1 ],
                 [ -1,  9, -1 ],
                 [ -1, -1, -1 ] ]; 

function preload() {
  img = loadImage('https://i.imgur.com/drZGUWw.png');
}

function setup() {
  createCanvas(720, 400);
  img.loadPixels();

  // pixelDensity(1) for not scaling pixel density to display density
  // for more information, check the reference of pixelDensity()
  pixelDensity(1);
}

function draw() {
  // We're only going to process a portion of the image
  // so let's set the whole image as the background first
  background(img);

  // Calculate the small rectangle we will process
  const xstart = constrain(mouseX - w/2, 0, img.width);
  const ystart = constrain(mouseY - w/2, 0, img.height);
  const xend = constrain(mouseX + w/2, 0, img.width);
  const yend = constrain(mouseY + w/2, 0, img.height);
  const matrixsize = 3;

  loadPixels();
  // Begin our loop for every pixel in the smaller image
  for (let x = xstart; x < xend; x++) {
    for (let y = ystart; y < yend; y++ ) {
      let c = convolution(x, y, matrix, matrixsize, img);
      
      // retrieve the RGBA values from c and update pixels()
      let loc = (x + y*img.width) * 4;
      pixels[loc] = red(c);
      pixels[loc + 1] = green(c);
      pixels[loc + 2] = blue(c);
      pixels[loc + 3] = alpha(c);
    }
  }
  updatePixels();
}

function convolution(x, y, matrix, matrixsize, img) {
  let rtotal = 0.0;
  let gtotal = 0.0;
  let btotal = 0.0;
  const offset = Math.floor(matrixsize / 2);
  for (let i = 0; i < matrixsize; i++){
    for (let j = 0; j < matrixsize; j++){
      
      // What pixel are we testing
      const xloc = (x + i - offset);
      const yloc = (y + j - offset);
      let loc = (xloc + img.width * yloc) * 4;

      // Make sure we haven't walked off our image, we could do better here
      loc = constrain(loc, 0 , img.pixels.length - 1);

      // Calculate the convolution
      // retrieve RGB values
      rtotal += (img.pixels[loc]) * matrix[i][j];
      gtotal += (img.pixels[loc + 1]) * matrix[i][j];
      btotal += (img.pixels[loc + 2]) * matrix[i][j];
    }
  }
  // Make sure RGB is within range
  rtotal = constrain(rtotal, 0, 255);
  gtotal = constrain(gtotal, 0, 255);
  btotal = constrain(btotal, 0, 255);
  
  // Return the resulting color
  return color(rtotal, gtotal, btotal);
} 

            </script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h1 id=the-coffee-shop-wall-illusion>The coffee shop wall illusion
<a class=anchor href=#the-coffee-shop-wall-illusion>#</a></h1><p>Esta ilusión de pared de cafetería ha saltado repetidamente del plano geométrico al mundo real en diferentes cafeterías o ubicaciones, gracias al atractivo visual que representa.</p><p>De hecho, uno de los libros más consultados por los amantes de las ilusiones ópticas ha sido escrito por Gregory y se titula El ojo y el cerebro, en el que, además de las aportaciones neurológicas, también aborda cuestiones de percepción, tema que ha inquietado. el autor a lo largo de su carrera profesional.</p><p>En esta ilusión de la pared de la cafetería todos los tramos son rectos, aunque la impresión es la contraria, ya que el contraste entre los tonos no permite visualizar claramente las líneas divisorias entre las filas. Por eso las pinturas crean la ilusión de ensancharse hacia los extremos.</p><p><a href=https://imgur.com/AdnD2na><img src=https://i.imgur.com/AdnD2na.jpg title="source: imgur.com"></a></p><h1 id=image-histragram>Image Histragram
<a class=anchor href=#image-histragram>#</a></h1><p>Un histograma de imagen es un tipo de histograma que actúa como una representación gráfica de la distribución tonal en una imagen digital. Traza el número de píxeles para cada valor tonal. Al mirar el histograma de una imagen específica, un espectador podrá juzgar la distribución tonal completa de un vistazo
<iframe id=breath style=width:600px;height:600px srcdoc='
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              


function preload() {
  img = loadImage("https://i.imgur.com/h016LEA.jpg"); // Load the image
}

function setup() {
  createCanvas(600, 600);
  background(255);
  img.resize(0,400);
  var maxRange = 256
  colorMode(HSL, maxRange);
  image(img, 0, 0);
  var histogram = new Array(maxRange);
  for (i = 0; i <= maxRange; i++) {
    histogram[i] = 0
  }

  loadPixels();
  
  for (var x = 0; x < img.width; x+=5) {
    for (var y = 0; y < img.height; y+=5) {
      var loc = (x + y * img.width) * 4;
      var h = pixels[loc];
      var s = pixels[loc + 1];
      var l = pixels[loc + 2];
      var a = pixels[loc + 3];
      b = int(l);
      histogram[b]++
    }
  }
  //img.filter(GRAY);
  image(img, 0, 0);
  stroke(300,100,80)
  push()
  translate(10,0)
  for (x = 0; x <= maxRange; x++) {
    index = histogram[x];

    y1=int(map(index, 0, max(histogram), height, height-200));
		y2 = height
    xPos = map(x,0,maxRange,0, width-20)
    line(xPos, y1, xPos, y2);
  }
  pop()
}



            </script>
          </head>
          <body>
          </body>
        </html>
      '></iframe></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/emmendezp/RGB/commit/8773cf76cb8a6cf1ed9ea510efdf35d18adf6545 title='Last modified by emmendezp | September 6, 2022' target=_blank rel=noopener><img src=/RGB/svg/calendar.svg class=book-icon alt=Calendar>
<span>September 6, 2022</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#taller-2--visual-masking>Taller 2 : Visual Masking</a><ul><li><a href=#planteamiento-del-problema>Planteamiento del problema</a></li><li><a href=#máscaras-de-convolución>Máscaras de convolución</a><ul><li><a href=#explicación-visual->Explicación visual :</a></li><li><a href=#ejemplo>Ejemplo</a></li></ul></li><li><a href=#image-kernel>Image Kernel</a><ul><li><a href=#convolution->Convolution :</a></li><li><a href=#example>Example</a></li></ul></li></ul></li><li><a href=#the-coffee-shop-wall-illusion>The coffee shop wall illusion</a></li><li><a href=#image-histragram>Image Histragram</a></li></ul></nav></div></aside></main></body></html>